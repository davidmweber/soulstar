use std::{env, fs};
use std::path::Path;
use serde::Deserialize;

// The device specific stuff we need to custom program a soul star from the souls.toml file
#[derive(Deserialize)]
struct DeviceConfig {
    id: String,
    bt_name: String,
    color: [u8; 3],
}

// Wrapper struct to match the top-level TOML structure
#[derive(Deserialize)]
struct Config {
    device: Vec<DeviceConfig>,
}

fn main() {
    // Pretty shamelessly AI code here. carefully eyeballed....
    
    // Force a rebuild if our soul configuration or the targeted soul has changed
    println!("cargo:rerun-if-changed=soul_config.toml");
    println!("cargo:rerun-if-env-changed=SOUL_ID");


    let dest_path = Path::new("src/soul_config.rs");
    // Read the environment variable to select the target soul
    let device_id =  match env::var("SOUL_ID") {
        Ok(id) => id,
        Err(_) => {
            // Use eprintln! to show this message in the terminal.
            eprintln!(
                "‚ö†Ô∏è  'SOUL_ID' not set. Generating a compile_error! stub. (This is expected for IDE background checks)."
            );
            panic!("No SOUL_ID environment variable configured.");
        }
    };
    
    // Read and parse the configuration file.
    let config_str = fs::read_to_string("souls.toml").expect("Could not read devices.toml");
    let config: Config = toml::from_str(&config_str).expect("Could not parse devices.toml");

    // Find the specific device's configuration.
    let device_config = config
        .device
        .into_iter()
        .find(|d| d.id == device_id)
        .unwrap_or_else(|| panic!("Could not find configuration for device ID: {}", device_id));

    // Generate the Rust code with the device's parameters.
    let generated_code = format!(
        r#"
// This file is automatically generated. Do not edit.

pub const ADVERTISED_NAME: &str = "{}";
pub const COLOUR: [u8; 3] = [{}, {}, {}];
"#,
        device_config.bt_name,
        device_config.color[0],
        device_config.color[1],
        device_config.color[2]
    );

    // 7. Write the generated code to the file.
    fs::write(&dest_path, generated_code).unwrap();
    eprintln!("‚úÖ Generated config for device: {}", device_id);
    
    // Linker stuff
    linker_be_nice();
    // make sure linkall.x is the last linker script (otherwise might cause problems with flip-link)
    println!("cargo:rustc-link-arg=-Tlinkall.x");
}

fn linker_be_nice() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() > 1 {
        let kind = &args[1];
        let what = &args[2];

        match kind.as_str() {
            "undefined-symbol" => match what.as_str() {
                "_defmt_timestamp" => {
                    eprintln!();
                    eprintln!(
                        "üí° `defmt` not found - make sure `defmt.x` is added as a linker script and you have included `use defmt_rtt as _;`"
                    );
                    eprintln!();
                }
                "_stack_start" => {
                    eprintln!();
                    eprintln!("üí° Is the linker script `linkall.x` missing?");
                    eprintln!();
                }
                "esp_wifi_preempt_enable" | "esp_wifi_preempt_yield_task" | "esp_wifi_preempt_task_create" => {
                    eprintln!();
                    eprintln!(
                        "üí° `esp-wifi` has no scheduler enabled. Make sure you have the `builtin-scheduler` feature enabled, or that you provide an external scheduler."
                    );
                    eprintln!();
                }
                "embedded_test_linker_file_not_added_to_rustflags" => {
                    eprintln!();
                    eprintln!(
                        "üí° `embedded-test` not found - make sure `embedded-test.x` is added as a linker script for tests"
                    );
                    eprintln!();
                }
                _ => (),
            },
            // we don't have anything helpful for "missing-lib" yet
            _ => {
                std::process::exit(1);
            }
        }

        std::process::exit(0);
    }

    println!("cargo:rustc-link-arg=--error-handling-script={}", std::env::current_exe().unwrap().display());
}
